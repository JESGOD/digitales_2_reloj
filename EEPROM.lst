CCS PCM C Compiler, Version 5.076, 56587               14-mar.-21 18:45

               Filename:   E:\PROGRAMAS UNIVERSIDAD\PICC\Ejercicios Digitales II\EEPROM\EEPROM.lst

               ROM used:   1409 words (17%)
                           Largest free fragment is 2048
               RAM used:   35 (10%) at main() level
                           61 (17%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   46F
0003:  NOP
.................... #INCLUDE <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,00
0015:  DATA 43,26
0016:  DATA 41,2B
0017:  DATA 45,10
0018:  DATA C1,21
0019:  DATA D4,2A
001A:  DATA 41,26
001B:  DATA 00,01
001C:  DATA 0C,00
001D:  DATA 43,26
001E:  DATA 41,2B
001F:  DATA 45,10
0020:  DATA CE,2A
0021:  DATA 45,2B
0022:  DATA 41,10
0023:  DATA 20,00
0024:  DATA 0C,00
0025:  DATA A0,21
0026:  DATA CC,20
0027:  DATA D6,22
0028:  DATA A0,24
0029:  DATA 4E,2B
002A:  DATA 41,26
002B:  DATA 49,22
002C:  DATA 41,10
002D:  DATA 00,01
002E:  DATA 0C,00
002F:  DATA 0C,00
0030:  DATA 20,22
0031:  DATA C9,23
0032:  DATA 49,2A
0033:  DATA 45,10
0034:  DATA 43,26
0035:  DATA 41,2B
0036:  DATA 45,10
0037:  DATA 00,01
0038:  DATA 0C,00
0039:  DATA A0,21
003A:  DATA CC,20
003B:  DATA D6,22
003C:  DATA A0,21
003D:  DATA 4F,29
003E:  DATA D2,22
003F:  DATA 43,2A
0040:  DATA 41,10
0041:  DATA 00,01
0042:  DATA 0C,00
0043:  DATA A0,21
0044:  DATA CC,20
0045:  DATA D6,22
0046:  DATA A0,24
0047:  DATA 4E,2B
0048:  DATA 41,26
0049:  DATA 49,22
004A:  DATA 41,10
004B:  DATA 00,00
*
00F4:  MOVLW  10
00F5:  MOVWF  57
00F6:  CLRF   77
00F7:  CLRF   7A
00F8:  RRF    54,F
00F9:  RRF    53,F
00FA:  BTFSS  03.0
00FB:  GOTO   102
00FC:  MOVF   55,W
00FD:  ADDWF  77,F
00FE:  BTFSC  03.0
00FF:  INCF   7A,F
0100:  MOVF   56,W
0101:  ADDWF  7A,F
0102:  RRF    7A,F
0103:  RRF    77,F
0104:  RRF    79,F
0105:  RRF    78,F
0106:  DECFSZ 57,F
0107:  GOTO   0F8
0108:  RETURN
0109:  CLRF   77
010A:  CLRF   78
010B:  MOVF   51,W
010C:  BCF    03.0
010D:  BTFSC  52.0
010E:  ADDWF  77,F
010F:  RRF    77,F
0110:  RRF    78,F
0111:  BTFSC  52.1
0112:  ADDWF  77,F
0113:  RRF    77,F
0114:  RRF    78,F
0115:  BTFSC  52.2
0116:  ADDWF  77,F
0117:  RRF    77,F
0118:  RRF    78,F
0119:  BTFSC  52.3
011A:  ADDWF  77,F
011B:  RRF    77,F
011C:  RRF    78,F
011D:  BTFSC  52.4
011E:  ADDWF  77,F
011F:  RRF    77,F
0120:  RRF    78,F
0121:  BTFSC  52.5
0122:  ADDWF  77,F
0123:  RRF    77,F
0124:  RRF    78,F
0125:  BTFSC  52.6
0126:  ADDWF  77,F
0127:  RRF    77,F
0128:  RRF    78,F
0129:  BTFSC  52.7
012A:  ADDWF  77,F
012B:  RRF    77,F
012C:  RRF    78,F
012D:  RETURN
*
016C:  MOVF   0B,W
016D:  MOVWF  47
016E:  BCF    0B.7
016F:  BSF    03.5
0170:  BSF    03.6
0171:  BSF    0C.7
0172:  BSF    0C.0
0173:  NOP
0174:  NOP
0175:  BCF    03.5
0176:  BCF    03.6
0177:  BTFSC  47.7
0178:  BSF    0B.7
0179:  BSF    03.6
017A:  MOVF   0C,W
017B:  ANDLW  7F
017C:  BTFSC  03.2
017D:  GOTO   1C0
017E:  BCF    03.6
017F:  MOVWF  47
0180:  BSF    03.6
0181:  MOVF   0D,W
0182:  BCF    03.6
0183:  MOVWF  48
0184:  BSF    03.6
0185:  MOVF   0F,W
0186:  BCF    03.6
0187:  MOVWF  49
0188:  MOVF   47,W
0189:  MOVWF  4A
018A:  CALL   140
018B:  MOVF   48,W
018C:  BSF    03.6
018D:  MOVWF  0D
018E:  BCF    03.6
018F:  MOVF   49,W
0190:  BSF    03.6
0191:  MOVWF  0F
0192:  BCF    03.6
0193:  MOVF   0B,W
0194:  MOVWF  4A
0195:  BCF    0B.7
0196:  BSF    03.5
0197:  BSF    03.6
0198:  BSF    0C.7
0199:  BSF    0C.0
019A:  NOP
019B:  NOP
019C:  BCF    03.5
019D:  BCF    03.6
019E:  BTFSC  4A.7
019F:  BSF    0B.7
01A0:  BSF    03.6
01A1:  RLF    0C,W
01A2:  RLF    0E,W
01A3:  ANDLW  7F
01A4:  BTFSC  03.2
01A5:  GOTO   1C0
01A6:  BCF    03.6
01A7:  MOVWF  47
01A8:  BSF    03.6
01A9:  MOVF   0D,W
01AA:  BCF    03.6
01AB:  MOVWF  48
01AC:  BSF    03.6
01AD:  MOVF   0F,W
01AE:  BCF    03.6
01AF:  MOVWF  49
01B0:  MOVF   47,W
01B1:  MOVWF  4A
01B2:  CALL   140
01B3:  MOVF   48,W
01B4:  BSF    03.6
01B5:  MOVWF  0D
01B6:  BCF    03.6
01B7:  MOVF   49,W
01B8:  BSF    03.6
01B9:  MOVWF  0F
01BA:  INCF   0D,F
01BB:  BTFSC  03.2
01BC:  INCF   0F,F
01BD:  BCF    03.6
01BE:  GOTO   16C
01BF:  BSF    03.6
01C0:  BCF    03.6
01C1:  RETURN
....................  
.................... #list 
....................  
.................... //#USE DELAY(CLOCK=4000000) // Reloj 4MHz 
.................... #use delay(clock=4000000,crystal)//Crystal Externo 4MHz 
*
004C:  MOVLW  4B
004D:  MOVWF  04
004E:  BCF    03.7
004F:  MOVF   00,W
0050:  BTFSC  03.2
0051:  GOTO   060
0052:  MOVLW  01
0053:  MOVWF  78
0054:  CLRF   77
0055:  DECFSZ 77,F
0056:  GOTO   055
0057:  DECFSZ 78,F
0058:  GOTO   054
0059:  MOVLW  4A
005A:  MOVWF  77
005B:  DECFSZ 77,F
005C:  GOTO   05B
005D:  GOTO   05E
005E:  DECFSZ 00,F
005F:  GOTO   052
0060:  RETURN
.................... #FUSES XT,NOPROTECT,NOWDT,NOBROWNOUT,NOPUT,NOLVP 
....................  
.................... //Definiciones para colocar el LCD y el teclado en el puerto B 
.................... #DEFINE USE_PORTB_LCD TRUE 
.................... #DEFINE USE_PORTB_KBD TRUE   
....................   
.................... //Librerías del LCD y Teclado 
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0079:  MOVLW  0F
007A:  BSF    03.5
007B:  ANDWF  06,W
007C:  IORLW  F0
007D:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
007E:  BCF    03.5
007F:  BSF    06.2
....................    delay_cycles(1); 
0080:  NOP
....................    lcd_output_enable(1); 
0081:  BSF    06.0
....................    delay_cycles(1); 
0082:  NOP
....................    high = lcd_read_nibble(); 
0083:  CALL   06D
0084:  MOVF   78,W
0085:  MOVWF  52
....................        
....................    lcd_output_enable(0); 
0086:  BCF    06.0
....................    delay_cycles(1); 
0087:  NOP
....................    lcd_output_enable(1); 
0088:  BSF    06.0
....................    delay_us(1); 
0089:  NOP
....................    low = lcd_read_nibble(); 
008A:  CALL   06D
008B:  MOVF   78,W
008C:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
008D:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
008E:  MOVLW  0F
008F:  BSF    03.5
0090:  ANDWF  06,W
0091:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0092:  BCF    03.5
0093:  SWAPF  52,W
0094:  MOVWF  77
0095:  MOVLW  F0
0096:  ANDWF  77,F
0097:  MOVF   77,W
0098:  IORWF  51,W
0099:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
006D:  MOVF   06,W
006E:  MOVWF  77
006F:  SWAPF  06,W
0070:  ANDLW  0F
0071:  MOVWF  78
....................   #endif 
0072:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0061:  SWAPF  52,W
0062:  ANDLW  F0
0063:  MOVWF  77
0064:  MOVLW  0F
0065:  ANDWF  06,W
0066:  IORWF  77,W
0067:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
0068:  NOP
....................    lcd_output_enable(1); 
0069:  BSF    06.0
....................    delay_us(2); 
006A:  GOTO   06B
....................    lcd_output_enable(0); 
006B:  BCF    06.0
006C:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0073:  BSF    03.5
0074:  BCF    06.0
....................    lcd_rs_tris(); 
0075:  BCF    06.1
....................    lcd_rw_tris(); 
0076:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0077:  BCF    03.5
0078:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
009A:  MOVF   78,W
009B:  MOVWF  51
009C:  BTFSC  51.7
009D:  GOTO   079
....................    lcd_output_rs(address); 
009E:  BTFSS  4F.0
009F:  BCF    06.1
00A0:  BTFSC  4F.0
00A1:  BSF    06.1
....................    delay_cycles(1); 
00A2:  NOP
....................    lcd_output_rw(0); 
00A3:  BCF    06.2
....................    delay_cycles(1); 
00A4:  NOP
....................    lcd_output_enable(0); 
00A5:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
00A6:  SWAPF  50,W
00A7:  MOVWF  51
00A8:  MOVLW  0F
00A9:  ANDWF  51,F
00AA:  MOVF   51,W
00AB:  MOVWF  52
00AC:  CALL   061
....................    lcd_send_nibble(n & 0xf); 
00AD:  MOVF   50,W
00AE:  ANDLW  0F
00AF:  MOVWF  51
00B0:  MOVWF  52
00B1:  CALL   061
00B2:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00B3:  MOVLW  28
00B4:  MOVWF  3D
00B5:  MOVLW  0C
00B6:  MOVWF  3E
00B7:  MOVLW  01
00B8:  MOVWF  3F
00B9:  MOVLW  06
00BA:  MOVWF  40
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00BB:  BCF    06.0
....................    lcd_output_rs(0); 
00BC:  BCF    06.1
....................    lcd_output_rw(0); 
00BD:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00BE:  MOVLW  0F
00BF:  BSF    03.5
00C0:  ANDWF  06,W
00C1:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
00C2:  BCF    06.0
....................    lcd_rs_tris(); 
00C3:  BCF    06.1
....................    lcd_rw_tris(); 
00C4:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
00C5:  MOVLW  0F
00C6:  BCF    03.5
00C7:  MOVWF  4B
00C8:  CALL   04C
....................    for(i=1;i<=3;++i) 
00C9:  MOVLW  01
00CA:  MOVWF  3C
00CB:  MOVF   3C,W
00CC:  SUBLW  03
00CD:  BTFSS  03.0
00CE:  GOTO   0D7
....................    { 
....................        lcd_send_nibble(3); 
00CF:  MOVLW  03
00D0:  MOVWF  52
00D1:  CALL   061
....................        delay_ms(5); 
00D2:  MOVLW  05
00D3:  MOVWF  4B
00D4:  CALL   04C
00D5:  INCF   3C,F
00D6:  GOTO   0CB
....................    } 
....................     
....................    lcd_send_nibble(2); 
00D7:  MOVLW  02
00D8:  MOVWF  52
00D9:  CALL   061
....................    delay_ms(5); 
00DA:  MOVLW  05
00DB:  MOVWF  4B
00DC:  CALL   04C
....................    for(i=0;i<=3;++i) 
00DD:  CLRF   3C
00DE:  MOVF   3C,W
00DF:  SUBLW  03
00E0:  BTFSS  03.0
00E1:  GOTO   0EE
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00E2:  MOVLW  3D
00E3:  ADDWF  3C,W
00E4:  MOVWF  04
00E5:  BCF    03.7
00E6:  MOVF   00,W
00E7:  MOVWF  41
00E8:  CLRF   4F
00E9:  MOVF   41,W
00EA:  MOVWF  50
00EB:  CALL   073
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00EC:  INCF   3C,F
00ED:  GOTO   0DE
00EE:  BCF    0A.3
00EF:  BCF    0A.4
00F0:  GOTO   496 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
012E:  DECFSZ 4C,W
012F:  GOTO   131
0130:  GOTO   134
....................       address=LCD_LINE_TWO; 
0131:  MOVLW  40
0132:  MOVWF  4D
0133:  GOTO   135
....................    else 
....................       address=0; 
0134:  CLRF   4D
....................       
....................    address+=x-1; 
0135:  MOVLW  01
0136:  SUBWF  4B,W
0137:  ADDWF  4D,F
....................    lcd_send_byte(0,0x80|address); 
0138:  MOVF   4D,W
0139:  IORLW  80
013A:  MOVWF  4E
013B:  CLRF   4F
013C:  MOVF   4E,W
013D:  MOVWF  50
013E:  CALL   073
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
013F:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0140:  MOVF   4A,W
0141:  XORLW  07
0142:  BTFSC  03.2
0143:  GOTO   14E
0144:  XORLW  0B
0145:  BTFSC  03.2
0146:  GOTO   153
0147:  XORLW  06
0148:  BTFSC  03.2
0149:  GOTO   15B
014A:  XORLW  02
014B:  BTFSC  03.2
014C:  GOTO   161
014D:  GOTO   166
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
014E:  MOVLW  01
014F:  MOVWF  4B
0150:  MOVWF  4C
0151:  CALL   12E
0152:  GOTO   16B
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0153:  CLRF   4F
0154:  MOVLW  01
0155:  MOVWF  50
0156:  CALL   073
....................                      delay_ms(2); 
0157:  MOVLW  02
0158:  MOVWF  4B
0159:  CALL   04C
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
015A:  GOTO   16B
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
015B:  MOVLW  01
015C:  MOVWF  4B
015D:  MOVLW  02
015E:  MOVWF  4C
015F:  CALL   12E
0160:  GOTO   16B
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0161:  CLRF   4F
0162:  MOVLW  10
0163:  MOVWF  50
0164:  CALL   073
0165:  GOTO   16B
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0166:  MOVLW  01
0167:  MOVWF  4F
0168:  MOVF   4A,W
0169:  MOVWF  50
016A:  CALL   073
....................      #endif 
....................    } 
016B:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #INCLUDE <KBD.C>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBD.C                                 //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
.................... #if defined use_portb_kbd 
....................    #byte kbd = getenv("SFR:PORTB") 
.................... #else 
....................    #byte kbd = getenv("SFR:PORTD") 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
*
00F1:  BCF    0A.3
00F2:  BCF    0A.4
00F3:  GOTO   497 (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
048A:  BCF    03.6
048B:  CLRF   20
....................    static int1 kbd_down; 
048C:  BCF    21.0
....................    static char last_key; 
048D:  CLRF   22
....................    static BYTE col; 
048E:  CLRF   23
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
01C2:  CLRF   47
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
01C3:  INCF   20,F
01C4:  MOVF   20,W
01C5:  SUBLW  21
01C6:  BTFSC  03.0
01C7:  GOTO   220
....................        switch (col) { 
01C8:  MOVF   23,W
01C9:  BTFSC  03.2
01CA:  GOTO   1D2
01CB:  XORLW  01
01CC:  BTFSC  03.2
01CD:  GOTO   1D8
01CE:  XORLW  03
01CF:  BTFSC  03.2
01D0:  GOTO   1DE
01D1:  GOTO   1E3
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
01D2:  MOVLW  DE
01D3:  BSF    03.5
01D4:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
01D5:  BCF    03.5
01D6:  MOVWF  06
....................                     break; 
01D7:  GOTO   1E3
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
01D8:  MOVLW  BE
01D9:  BSF    03.5
01DA:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
01DB:  BCF    03.5
01DC:  MOVWF  06
....................                     break; 
01DD:  GOTO   1E3
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
01DE:  MOVLW  7E
01DF:  BSF    03.5
01E0:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
01E1:  BCF    03.5
01E2:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
01E3:  BTFSS  21.0
01E4:  GOTO   1EF
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
01E5:  MOVF   06,W
01E6:  ANDLW  1E
01E7:  SUBLW  1E
01E8:  BTFSS  03.2
01E9:  GOTO   1EE
....................            kbd_down=FALSE; 
01EA:  BCF    21.0
....................            kchar=last_key; 
01EB:  MOVF   22,W
01EC:  MOVWF  47
....................            last_key='\0'; 
01ED:  CLRF   22
....................          } 
....................        } else { 
01EE:  GOTO   21F
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
01EF:  MOVF   06,W
01F0:  ANDLW  1E
01F1:  SUBLW  1E
01F2:  BTFSC  03.2
01F3:  GOTO   21A
....................              if((kbd & ROW0)==0) 
01F4:  MOVF   06,W
01F5:  ANDLW  02
01F6:  BTFSS  03.2
01F7:  GOTO   1FA
....................                row=0; 
01F8:  CLRF   48
01F9:  GOTO   20E
....................              else if((kbd & ROW1)==0) 
01FA:  MOVF   06,W
01FB:  ANDLW  04
01FC:  BTFSS  03.2
01FD:  GOTO   201
....................                row=1; 
01FE:  MOVLW  01
01FF:  MOVWF  48
0200:  GOTO   20E
....................              else if((kbd & ROW2)==0) 
0201:  MOVF   06,W
0202:  ANDLW  08
0203:  BTFSS  03.2
0204:  GOTO   208
....................                row=2; 
0205:  MOVLW  02
0206:  MOVWF  48
0207:  GOTO   20E
....................              else if((kbd & ROW3)==0) 
0208:  MOVF   06,W
0209:  ANDLW  10
020A:  BTFSS  03.2
020B:  GOTO   20E
....................                row=3; 
020C:  MOVLW  03
020D:  MOVWF  48
....................              last_key =KEYS[row][col]; 
020E:  MOVF   48,W
020F:  MOVWF  51
0210:  MOVLW  03
0211:  MOVWF  52
0212:  CALL   109
0213:  MOVF   23,W
0214:  ADDWF  78,W
0215:  CALL   004
0216:  MOVWF  78
0217:  MOVWF  22
....................              kbd_down = TRUE; 
0218:  BSF    21.0
....................           } else { 
0219:  GOTO   21F
....................              ++col; 
021A:  INCF   23,F
....................              if(col==3) 
021B:  MOVF   23,W
021C:  SUBLW  03
021D:  BTFSC  03.2
....................                col=0; 
021E:  CLRF   23
....................           } 
....................        } 
....................       kbd_call_count=0; 
021F:  CLRF   20
....................    } 
....................   set_tris_kbd(ALL_PINS); 
0220:  MOVLW  FE
0221:  BSF    03.5
0222:  MOVWF  06
....................   return(kchar); 
0223:  BCF    03.5
0224:  MOVF   47,W
0225:  MOVWF  78
0226:  RETURN
.................... } 
....................  
....................  
.................... //Definiciones 
.................... #BYTE PORTC= 7 
.................... #BYTE PORTB= 6 
.................... #DEFINE LED1 PORTC,4 
.................... #DEFINE LED2 PORTC,7 
....................  
.................... //Variables Globales 
.................... CHAR K; 
.................... INT8 MIL,CEN,DEC,UNI,VAL; 
.................... INT16 contra=9999; //Variable entera para almacenar la contraseña 
.................... INT8 sinal; //Variable para saber si tengo contraseña 
....................  
.................... VOID TECLADO() 
.................... { 
....................    k=kbd_getc(); //Llamar la función del teclado y almacenar 
0227:  CALL   1C2
0228:  MOVF   78,W
0229:  MOVWF  24
....................    //el valor digitado en una variable tipo 
....................    //carácter. Si no se oprime ninguna tecla el 
....................    //teclado retornara el carácter nulo.*/ 
....................    WHILE(k=='\0') //si no se oprime ninguna tecla sigue llamando al teclado. 
022A:  MOVF   24,F
022B:  BTFSS  03.2
022C:  GOTO   231
....................    { 
....................       k=kbd_getc(); 
022D:  CALL   1C2
022E:  MOVF   78,W
022F:  MOVWF  24
0230:  GOTO   22A
....................    } 
....................    IF( (k!='\0')) 
0231:  MOVF   24,F
0232:  BTFSC  03.2
0233:  GOTO   26E
....................    { 
....................       IF(K=='0')//Si K es igual a cero 
0234:  MOVF   24,W
0235:  SUBLW  30
0236:  BTFSC  03.2
....................          VAL=0;//Val es igual a cero 
0237:  CLRF   29
....................       IF(K=='1') 
0238:  MOVF   24,W
0239:  SUBLW  31
023A:  BTFSS  03.2
023B:  GOTO   23E
....................          VAL=1; 
023C:  MOVLW  01
023D:  MOVWF  29
....................       IF(K=='2') 
023E:  MOVF   24,W
023F:  SUBLW  32
0240:  BTFSS  03.2
0241:  GOTO   244
....................          VAL=2; 
0242:  MOVLW  02
0243:  MOVWF  29
....................       IF(K=='3') 
0244:  MOVF   24,W
0245:  SUBLW  33
0246:  BTFSS  03.2
0247:  GOTO   24A
....................          VAL=3; 
0248:  MOVLW  03
0249:  MOVWF  29
....................       IF(K=='4') 
024A:  MOVF   24,W
024B:  SUBLW  34
024C:  BTFSS  03.2
024D:  GOTO   250
....................          VAL=4; 
024E:  MOVLW  04
024F:  MOVWF  29
....................       IF(K=='5') 
0250:  MOVF   24,W
0251:  SUBLW  35
0252:  BTFSS  03.2
0253:  GOTO   256
....................          VAL=5; 
0254:  MOVLW  05
0255:  MOVWF  29
....................       IF(K=='6') 
0256:  MOVF   24,W
0257:  SUBLW  36
0258:  BTFSS  03.2
0259:  GOTO   25C
....................          VAL=6; 
025A:  MOVLW  06
025B:  MOVWF  29
....................       IF(K=='7') 
025C:  MOVF   24,W
025D:  SUBLW  37
025E:  BTFSS  03.2
025F:  GOTO   262
....................          VAL=7; 
0260:  MOVLW  07
0261:  MOVWF  29
....................       IF(K=='8') 
0262:  MOVF   24,W
0263:  SUBLW  38
0264:  BTFSS  03.2
0265:  GOTO   268
....................          VAL=8; 
0266:  MOVLW  08
0267:  MOVWF  29
....................       IF(K=='9') 
0268:  MOVF   24,W
0269:  SUBLW  39
026A:  BTFSS  03.2
026B:  GOTO   26E
....................          VAL=9; 
026C:  MOVLW  09
026D:  MOVWF  29
....................    } 
026E:  RETURN
.................... } 
....................  
.................... //Rutina para pedir la clave 
.................... void pedir_clave(void) 
.................... { 
....................       TECLADO(); 
026F:  CALL   227
....................        
....................       IF((k!='#')&&(k!='*')) 
0270:  MOVF   24,W
0271:  SUBLW  23
0272:  BTFSC  03.2
0273:  GOTO   27D
0274:  MOVF   24,W
0275:  SUBLW  2A
0276:  BTFSC  03.2
0277:  GOTO   27D
....................       { 
....................          lcd_putc('*'); 
0278:  MOVLW  2A
0279:  MOVWF  4A
027A:  CALL   140
....................          MIL=VAL; 
027B:  MOVF   29,W
027C:  MOVWF  25
....................       } 
....................       if(k=='*' || k=='#') 
027D:  MOVF   24,W
027E:  SUBLW  2A
027F:  BTFSC  03.2
0280:  GOTO   284
0281:  MOVF   24,W
0282:  SUBLW  23
0283:  BTFSC  03.2
....................          return; 
0284:  GOTO   2C7
....................       TECLADO(); 
0285:  CALL   227
....................       IF((k!='#')&&(k!='*')) 
0286:  MOVF   24,W
0287:  SUBLW  23
0288:  BTFSC  03.2
0289:  GOTO   293
028A:  MOVF   24,W
028B:  SUBLW  2A
028C:  BTFSC  03.2
028D:  GOTO   293
....................       { 
....................          lcd_putc('*'); 
028E:  MOVLW  2A
028F:  MOVWF  4A
0290:  CALL   140
....................          CEN=VAL; 
0291:  MOVF   29,W
0292:  MOVWF  26
....................       } 
....................       if(k=='*' || k=='#') 
0293:  MOVF   24,W
0294:  SUBLW  2A
0295:  BTFSC  03.2
0296:  GOTO   29A
0297:  MOVF   24,W
0298:  SUBLW  23
0299:  BTFSC  03.2
....................          return; 
029A:  GOTO   2C7
....................       TECLADO(); 
029B:  CALL   227
....................       IF((k!='#')&&(k!='*')) 
029C:  MOVF   24,W
029D:  SUBLW  23
029E:  BTFSC  03.2
029F:  GOTO   2A9
02A0:  MOVF   24,W
02A1:  SUBLW  2A
02A2:  BTFSC  03.2
02A3:  GOTO   2A9
....................       { 
....................          lcd_putc('*'); 
02A4:  MOVLW  2A
02A5:  MOVWF  4A
02A6:  CALL   140
....................          DEC=VAL; 
02A7:  MOVF   29,W
02A8:  MOVWF  27
....................       } 
....................       if(k=='*' || k=='#') 
02A9:  MOVF   24,W
02AA:  SUBLW  2A
02AB:  BTFSC  03.2
02AC:  GOTO   2B0
02AD:  MOVF   24,W
02AE:  SUBLW  23
02AF:  BTFSC  03.2
....................          return; 
02B0:  GOTO   2C7
....................       TECLADO(); 
02B1:  CALL   227
....................       IF((k!='#')&&(k!='*')) 
02B2:  MOVF   24,W
02B3:  SUBLW  23
02B4:  BTFSC  03.2
02B5:  GOTO   2BF
02B6:  MOVF   24,W
02B7:  SUBLW  2A
02B8:  BTFSC  03.2
02B9:  GOTO   2BF
....................       { 
....................          lcd_putc('*'); 
02BA:  MOVLW  2A
02BB:  MOVWF  4A
02BC:  CALL   140
....................          UNI=VAL; 
02BD:  MOVF   29,W
02BE:  MOVWF  28
....................       } 
....................       if(k=='*' || k=='#') 
02BF:  MOVF   24,W
02C0:  SUBLW  2A
02C1:  BTFSC  03.2
02C2:  GOTO   2C6
02C3:  MOVF   24,W
02C4:  SUBLW  23
02C5:  BTFSC  03.2
....................          return; 
02C6:  GOTO   2C7
02C7:  RETURN
....................     
.................... } 
....................  
.................... int validar_clave(void) 
02C8:  CLRF   48
02C9:  CLRF   47
....................  
.................... { 
....................    //Variables locales 
....................    int16 clave=0,m,c,d,u; 
....................     
....................    /* Para realizar la multiplicación cuando se tienen numeros del tipo int8,  
....................       como por ejemplo 100 con otro tipo int8 como por ejemplo CEN, el programa 
....................       hará un producto int8, sin embargo se desea un resultado int16, por lo  
....................       tanto debe informarce al compilador por medio de un 'cast' (c=(int16)CEN*100) 
....................       o utilizando la función de multiplicación de tipos del compilador (_mul)*/ 
....................        
....................    m=MIL*1000; //Convierto miles a numero 
02CA:  CLRF   54
02CB:  MOVF   25,W
02CC:  MOVWF  53
02CD:  MOVLW  03
02CE:  MOVWF  56
02CF:  MOVLW  E8
02D0:  MOVWF  55
02D1:  CALL   0F4
02D2:  MOVF   79,W
02D3:  MOVWF  4A
02D4:  MOVF   78,W
02D5:  MOVWF  49
....................    //c=_mul(CEN,100); //Otra alternativa para multiplicar int8*int8=int16 
....................    c=(int16)CEN*100; //Convierto centemas, haciendo un CAST para obtener un int16 
02D6:  CLRF   52
02D7:  MOVF   26,W
02D8:  MOVWF  51
02D9:  MOVF   52,W
02DA:  MOVWF  54
02DB:  MOVF   26,W
02DC:  MOVWF  53
02DD:  CLRF   56
02DE:  MOVLW  64
02DF:  MOVWF  55
02E0:  CALL   0F4
02E1:  MOVF   79,W
02E2:  MOVWF  4C
02E3:  MOVF   78,W
02E4:  MOVWF  4B
....................    d=DEC*10; //Convierto decenas a numero  
02E5:  MOVF   27,W
02E6:  MOVWF  51
02E7:  MOVLW  0A
02E8:  MOVWF  52
02E9:  CALL   109
02EA:  CLRF   4E
02EB:  MOVF   78,W
02EC:  MOVWF  4D
....................    u=UNI; //Convierto unidades a numero  
02ED:  CLRF   50
02EE:  MOVF   28,W
02EF:  MOVWF  4F
....................     
....................    clave=m+c+d+u; 
02F0:  MOVF   4B,W
02F1:  ADDWF  49,W
02F2:  MOVWF  51
02F3:  MOVF   4A,W
02F4:  MOVWF  52
02F5:  MOVF   4C,W
02F6:  BTFSC  03.0
02F7:  INCFSZ 4C,W
02F8:  ADDWF  52,F
02F9:  MOVF   4D,W
02FA:  ADDWF  51,F
02FB:  MOVF   4E,W
02FC:  BTFSC  03.0
02FD:  INCFSZ 4E,W
02FE:  ADDWF  52,F
02FF:  MOVF   4F,W
0300:  ADDWF  51,W
0301:  MOVWF  47
0302:  MOVF   52,W
0303:  MOVWF  48
0304:  MOVF   50,W
0305:  BTFSC  03.0
0306:  INCFSZ 50,W
0307:  ADDWF  48,F
....................    //Borra lo último que fue digitado en el teclado 
....................    MIL=0;CEN=0;DEC=0;UNI=0;  
0308:  CLRF   25
0309:  CLRF   26
030A:  CLRF   27
030B:  CLRF   28
....................    if(clave==contra) //Si la clave es igual a la contraseña 
030C:  MOVF   2A,W
030D:  SUBWF  47,W
030E:  BTFSS  03.2
030F:  GOTO   318
0310:  MOVF   2B,W
0311:  SUBWF  48,W
0312:  BTFSS  03.2
0313:  GOTO   318
....................       return(1); 
0314:  MOVLW  01
0315:  MOVWF  78
0316:  GOTO   31A
0317:  GOTO   31A
....................    else 
....................       return(0); 
0318:  MOVLW  00
0319:  MOVWF  78
031A:  RETURN
.................... } 
....................  
.................... void cambio_clave(void) 
031B:  CLRF   3C
031C:  CLRF   3E
031D:  CLRF   3D
.................... { 
....................       int bandera=0; 
....................       int16 clave=0,m,c,d,u; 
....................        
....................       LCD_PUTC("\f"); 
031E:  MOVLW  14
031F:  BSF    03.6
0320:  MOVWF  0D
0321:  MOVLW  00
0322:  MOVWF  0F
0323:  BCF    03.6
0324:  CALL   16C
....................       LCD_GOTOXY(1,1); 
0325:  MOVLW  01
0326:  MOVWF  4B
0327:  MOVWF  4C
0328:  CALL   12E
....................       LCD_PUTC("CLAVE ACTUAL"); 
0329:  MOVLW  15
032A:  BSF    03.6
032B:  MOVWF  0D
032C:  MOVLW  00
032D:  MOVWF  0F
032E:  BCF    03.6
032F:  CALL   16C
....................       LCD_GOTOXY(1,2);       
0330:  MOVLW  01
0331:  MOVWF  4B
0332:  MOVLW  02
0333:  MOVWF  4C
0334:  CALL   12E
....................       pedir_clave(); //Llama la funcion de pedir la clave 
0335:  CALL   26F
....................       //bandera=validar_clave(); //Compruebo si la clave actual es correcta 
....................       if(validar_clave()) 
0336:  CALL   2C8
0337:  MOVF   78,F
0338:  BTFSC  03.2
0339:  GOTO   44B
....................       { 
....................          LCD_PUTC("\f"); 
033A:  MOVLW  1C
033B:  BSF    03.6
033C:  MOVWF  0D
033D:  MOVLW  00
033E:  MOVWF  0F
033F:  BCF    03.6
0340:  CALL   16C
....................          LCD_GOTOXY(1,1); 
0341:  MOVLW  01
0342:  MOVWF  4B
0343:  MOVWF  4C
0344:  CALL   12E
....................          LCD_PUTC("CLAVE NUEVA  "); 
0345:  MOVLW  1D
0346:  BSF    03.6
0347:  MOVWF  0D
0348:  MOVLW  00
0349:  MOVWF  0F
034A:  BCF    03.6
034B:  CALL   16C
....................          LCD_GOTOXY(1,2);    
034C:  MOVLW  01
034D:  MOVWF  4B
034E:  MOVLW  02
034F:  MOVWF  4C
0350:  CALL   12E
....................          TECLADO(); 
0351:  CALL   227
....................          IF((k!='#')&&(k!='*')) 
0352:  MOVF   24,W
0353:  SUBLW  23
0354:  BTFSC  03.2
0355:  GOTO   35F
0356:  MOVF   24,W
0357:  SUBLW  2A
0358:  BTFSC  03.2
0359:  GOTO   35F
....................          { 
....................             lcd_putc('*'); 
035A:  MOVLW  2A
035B:  MOVWF  4A
035C:  CALL   140
....................             MIL=VAL; 
035D:  MOVF   29,W
035E:  MOVWF  25
....................          } 
....................          
....................          TECLADO(); 
035F:  CALL   227
....................          IF((k!='#')&&(k!='*')) 
0360:  MOVF   24,W
0361:  SUBLW  23
0362:  BTFSC  03.2
0363:  GOTO   36D
0364:  MOVF   24,W
0365:  SUBLW  2A
0366:  BTFSC  03.2
0367:  GOTO   36D
....................          { 
....................             lcd_putc('*'); 
0368:  MOVLW  2A
0369:  MOVWF  4A
036A:  CALL   140
....................             CEN=VAL; 
036B:  MOVF   29,W
036C:  MOVWF  26
....................          } 
....................           
....................          TECLADO(); 
036D:  CALL   227
....................          IF((k!='#')&&(k!='*')) 
036E:  MOVF   24,W
036F:  SUBLW  23
0370:  BTFSC  03.2
0371:  GOTO   37B
0372:  MOVF   24,W
0373:  SUBLW  2A
0374:  BTFSC  03.2
0375:  GOTO   37B
....................          { 
....................             lcd_putc('*'); 
0376:  MOVLW  2A
0377:  MOVWF  4A
0378:  CALL   140
....................             DEC=VAL; 
0379:  MOVF   29,W
037A:  MOVWF  27
....................          } 
....................           
....................          TECLADO(); 
037B:  CALL   227
....................          IF((k!='#')&&(k!='*')) 
037C:  MOVF   24,W
037D:  SUBLW  23
037E:  BTFSC  03.2
037F:  GOTO   389
0380:  MOVF   24,W
0381:  SUBLW  2A
0382:  BTFSC  03.2
0383:  GOTO   389
....................          { 
....................             lcd_putc('*'); 
0384:  MOVLW  2A
0385:  MOVWF  4A
0386:  CALL   140
....................             UNI=VAL; 
0387:  MOVF   29,W
0388:  MOVWF  28
....................          } 
....................           
....................          m=MIL*1000; //Convierto miles a numero 
0389:  CLRF   54
038A:  MOVF   25,W
038B:  MOVWF  53
038C:  MOVLW  03
038D:  MOVWF  56
038E:  MOVLW  E8
038F:  MOVWF  55
0390:  CALL   0F4
0391:  MOVF   79,W
0392:  MOVWF  40
0393:  MOVF   78,W
0394:  MOVWF  3F
....................          c=CEN*10; //Convierto centemas a numero y lo sumo al anterior 
0395:  MOVF   26,W
0396:  MOVWF  51
0397:  MOVLW  0A
0398:  MOVWF  52
0399:  CALL   109
039A:  CLRF   42
039B:  MOVF   78,W
039C:  MOVWF  41
....................          c=c*10; 
039D:  MOVF   42,W
039E:  MOVWF  54
039F:  MOVF   41,W
03A0:  MOVWF  53
03A1:  CLRF   56
03A2:  MOVLW  0A
03A3:  MOVWF  55
03A4:  CALL   0F4
03A5:  MOVF   79,W
03A6:  MOVWF  42
03A7:  MOVF   78,W
03A8:  MOVWF  41
....................          d=DEC*10; //Convierto decenas a numero y lo sumo al anterior 
03A9:  MOVF   27,W
03AA:  MOVWF  51
03AB:  MOVLW  0A
03AC:  MOVWF  52
03AD:  CALL   109
03AE:  CLRF   44
03AF:  MOVF   78,W
03B0:  MOVWF  43
....................          u=UNI; //Convierto unidades a numero y lo sumo al anterior 
03B1:  CLRF   46
03B2:  MOVF   28,W
03B3:  MOVWF  45
....................           
....................          clave=m+c+d+u; 
03B4:  MOVF   41,W
03B5:  ADDWF  3F,W
03B6:  MOVWF  47
03B7:  MOVF   40,W
03B8:  MOVWF  48
03B9:  MOVF   42,W
03BA:  BTFSC  03.0
03BB:  INCFSZ 42,W
03BC:  ADDWF  48,F
03BD:  MOVF   43,W
03BE:  ADDWF  47,F
03BF:  MOVF   44,W
03C0:  BTFSC  03.0
03C1:  INCFSZ 44,W
03C2:  ADDWF  48,F
03C3:  MOVF   45,W
03C4:  ADDWF  47,W
03C5:  MOVWF  3D
03C6:  MOVF   48,W
03C7:  MOVWF  3E
03C8:  MOVF   46,W
03C9:  BTFSC  03.0
03CA:  INCFSZ 46,W
03CB:  ADDWF  3E,F
....................           
....................          contra=clave; 
03CC:  MOVF   3E,W
03CD:  MOVWF  2B
03CE:  MOVF   3D,W
03CF:  MOVWF  2A
....................          WRITE_EEPROM(0,MIL); //Guarda en la eemprom posicion cero la nueva contraseña 
03D0:  MOVF   0B,W
03D1:  MOVWF  77
03D2:  BCF    0B.7
03D3:  BSF    03.6
03D4:  CLRF   0D
03D5:  BCF    03.6
03D6:  MOVF   25,W
03D7:  BSF    03.6
03D8:  MOVWF  0C
03D9:  BSF    03.5
03DA:  BCF    0C.7
03DB:  BSF    0C.2
03DC:  MOVLW  55
03DD:  MOVWF  0D
03DE:  MOVLW  AA
03DF:  MOVWF  0D
03E0:  BSF    0C.1
03E1:  BTFSC  0C.1
03E2:  GOTO   3E1
03E3:  BCF    0C.2
03E4:  MOVF   77,W
03E5:  BCF    03.5
03E6:  BCF    03.6
03E7:  IORWF  0B,F
....................          WRITE_EEPROM(1,CEN); 
03E8:  MOVF   0B,W
03E9:  MOVWF  77
03EA:  BCF    0B.7
03EB:  MOVLW  01
03EC:  BSF    03.6
03ED:  MOVWF  0D
03EE:  BCF    03.6
03EF:  MOVF   26,W
03F0:  BSF    03.6
03F1:  MOVWF  0C
03F2:  BSF    03.5
03F3:  BCF    0C.7
03F4:  BSF    0C.2
03F5:  MOVLW  55
03F6:  MOVWF  0D
03F7:  MOVLW  AA
03F8:  MOVWF  0D
03F9:  BSF    0C.1
03FA:  BTFSC  0C.1
03FB:  GOTO   3FA
03FC:  BCF    0C.2
03FD:  MOVF   77,W
03FE:  BCF    03.5
03FF:  BCF    03.6
0400:  IORWF  0B,F
....................          WRITE_EEPROM(2,DEC); 
0401:  MOVF   0B,W
0402:  MOVWF  77
0403:  BCF    0B.7
0404:  MOVLW  02
0405:  BSF    03.6
0406:  MOVWF  0D
0407:  BCF    03.6
0408:  MOVF   27,W
0409:  BSF    03.6
040A:  MOVWF  0C
040B:  BSF    03.5
040C:  BCF    0C.7
040D:  BSF    0C.2
040E:  MOVLW  55
040F:  MOVWF  0D
0410:  MOVLW  AA
0411:  MOVWF  0D
0412:  BSF    0C.1
0413:  BTFSC  0C.1
0414:  GOTO   413
0415:  BCF    0C.2
0416:  MOVF   77,W
0417:  BCF    03.5
0418:  BCF    03.6
0419:  IORWF  0B,F
....................          WRITE_EEPROM(3,UNI); 
041A:  MOVF   0B,W
041B:  MOVWF  77
041C:  BCF    0B.7
041D:  MOVLW  03
041E:  BSF    03.6
041F:  MOVWF  0D
0420:  BCF    03.6
0421:  MOVF   28,W
0422:  BSF    03.6
0423:  MOVWF  0C
0424:  BSF    03.5
0425:  BCF    0C.7
0426:  BSF    0C.2
0427:  MOVLW  55
0428:  MOVWF  0D
0429:  MOVLW  AA
042A:  MOVWF  0D
042B:  BSF    0C.1
042C:  BTFSC  0C.1
042D:  GOTO   42C
042E:  BCF    0C.2
042F:  MOVF   77,W
0430:  BCF    03.5
0431:  BCF    03.6
0432:  IORWF  0B,F
....................          WRITE_EEPROM(4,12); //Guardo un 12 en la posicion 1 de la EEPROM, para decir que tengo 
0433:  MOVF   0B,W
0434:  MOVWF  77
0435:  BCF    0B.7
0436:  MOVLW  04
0437:  BSF    03.6
0438:  MOVWF  0D
0439:  MOVLW  0C
043A:  MOVWF  0C
043B:  BSF    03.5
043C:  BCF    0C.7
043D:  BSF    0C.2
043E:  MOVLW  55
043F:  MOVWF  0D
0440:  MOVLW  AA
0441:  MOVWF  0D
0442:  BSF    0C.1
0443:  BTFSC  0C.1
0444:  GOTO   443
0445:  BCF    0C.2
0446:  MOVF   77,W
0447:  BCF    03.5
0448:  BCF    03.6
0449:  IORWF  0B,F
....................                               //una contraseña guardada 
....................           
....................       } 
044A:  GOTO   46E
....................       else 
....................       { 
....................          LCD_PUTC("\f"); 
044B:  MOVLW  24
044C:  BSF    03.6
044D:  MOVWF  0D
044E:  MOVLW  00
044F:  MOVWF  0F
0450:  BCF    03.6
0451:  CALL   16C
....................          LCD_GOTOXY(1,2); 
0452:  MOVLW  01
0453:  MOVWF  4B
0454:  MOVLW  02
0455:  MOVWF  4C
0456:  CALL   12E
....................          LCD_PUTC(" CLAVE INVALIDA "); 
0457:  MOVLW  25
0458:  BSF    03.6
0459:  MOVWF  0D
045A:  MOVLW  00
045B:  MOVWF  0F
045C:  BCF    03.6
045D:  CALL   16C
....................          BIT_SET(LED2); 
045E:  BSF    07.7
....................          DELAY_MS(4000); 
045F:  MOVLW  10
0460:  MOVWF  47
0461:  MOVLW  FA
0462:  MOVWF  4B
0463:  CALL   04C
0464:  DECFSZ 47,F
0465:  GOTO   461
....................          BIT_CLEAR(LED2); 
0466:  BCF    07.7
....................          LCD_PUTC("\f"); 
0467:  MOVLW  2E
0468:  BSF    03.6
0469:  MOVWF  0D
046A:  MOVLW  00
046B:  MOVWF  0F
046C:  BCF    03.6
046D:  CALL   16C
....................       } 
046E:  RETURN
.................... } 
.................... VOID MAIN() 
046F:  MOVF   03,W
0470:  ANDLW  1F
0471:  MOVWF  03
0472:  MOVLW  27
0473:  MOVWF  2B
0474:  MOVLW  0F
0475:  MOVWF  2A
0476:  CLRF   2E
0477:  CLRF   2D
0478:  MOVLW  FF
0479:  MOVWF  2F
047A:  BSF    03.5
047B:  BSF    03.6
047C:  MOVF   09,W
047D:  ANDLW  C0
047E:  MOVWF  09
047F:  BCF    03.6
0480:  BCF    1F.4
0481:  BCF    1F.5
0482:  MOVLW  00
0483:  BSF    03.6
0484:  MOVWF  08
0485:  BCF    03.5
0486:  CLRF   07
0487:  CLRF   08
0488:  CLRF   09
0489:  BCF    03.7
.................... { 
....................    //Variables Locales 
....................    int16 m,c,d,u; 
....................    INT8 m1,c1,d1,u1; 
....................     
....................    //Puerto C como Salida 
....................    SET_TRIS_C(0B00000000); 
*
048F:  MOVLW  00
0490:  BSF    03.5
0491:  MOVWF  07
0492:  BCF    03.5
0493:  MOVWF  2F
....................    PORTC=0; //Limpia Puerto C 
0494:  CLRF   07
....................     
....................    lcd_init(); //Inicializa el LCD 
0495:  GOTO   0B3
....................    kbd_init(); //Inicializa el Teclado 
0496:  GOTO   0F1
....................   
....................    //Configura las Resistencias PULL-UP del Puerto B 
....................    port_b_pullups(0xFF); //PIC16F887 
0497:  MOVLW  FF
0498:  BSF    03.5
0499:  MOVWF  15
049A:  BCF    01.7
....................    //port_b_pullups(TRUE); //PIC16F877A 
....................     
....................    sinal=READ_EEPROM(4); //Averiguo si tengo una contraseña guardada o no 
049B:  MOVLW  04
049C:  BCF    03.5
049D:  BSF    03.6
049E:  MOVWF  0D
049F:  BSF    03.5
04A0:  BCF    0C.7
04A1:  BSF    0C.0
04A2:  BCF    03.5
04A3:  MOVF   0C,W
04A4:  BCF    03.6
04A5:  MOVWF  2C
....................    if(sinal!=12) 
04A6:  MOVF   2C,W
04A7:  SUBLW  0C
04A8:  BTFSC  03.2
04A9:  GOTO   4AF
....................       contra=9999; 
04AA:  MOVLW  27
04AB:  MOVWF  2B
04AC:  MOVLW  0F
04AD:  MOVWF  2A
04AE:  GOTO   514
....................    else 
....................    {  
....................      //Lee los datos del EEPROM 
....................       m1=READ_EEPROM(0);  
04AF:  BSF    03.6
04B0:  CLRF   0D
04B1:  BSF    03.5
04B2:  BCF    0C.7
04B3:  BSF    0C.0
04B4:  BCF    03.5
04B5:  MOVF   0C,W
04B6:  BCF    03.6
04B7:  MOVWF  38
....................       c1=READ_EEPROM(1);  
04B8:  MOVLW  01
04B9:  BSF    03.6
04BA:  MOVWF  0D
04BB:  BSF    03.5
04BC:  BCF    0C.7
04BD:  BSF    0C.0
04BE:  BCF    03.5
04BF:  MOVF   0C,W
04C0:  BCF    03.6
04C1:  MOVWF  39
....................       d1=READ_EEPROM(2);  
04C2:  MOVLW  02
04C3:  BSF    03.6
04C4:  MOVWF  0D
04C5:  BSF    03.5
04C6:  BCF    0C.7
04C7:  BSF    0C.0
04C8:  BCF    03.5
04C9:  MOVF   0C,W
04CA:  BCF    03.6
04CB:  MOVWF  3A
....................       u1=READ_EEPROM(3);  
04CC:  MOVLW  03
04CD:  BSF    03.6
04CE:  MOVWF  0D
04CF:  BSF    03.5
04D0:  BCF    0C.7
04D1:  BSF    0C.0
04D2:  BCF    03.5
04D3:  MOVF   0C,W
04D4:  BCF    03.6
04D5:  MOVWF  3B
....................     
....................    /* Para realizar la multiplicación cuando se tienen numeros del tipo int8,  
....................       como por ejemplo 100 con otro tipo int8 como por ejemplo CEN, el programa 
....................       hará un producto int8, sin embargo se desea un resultado int16, por lo  
....................       tanto debe informarce al compilador por medio de un 'cast' (c=(int16)CEN*100) 
....................       o utilizando la función de multiplicación de tipos del compilador (_mul)*/ 
....................        
....................       m=m1*1000; //Convierto miles a numero 
04D6:  CLRF   54
04D7:  MOVF   38,W
04D8:  MOVWF  53
04D9:  MOVLW  03
04DA:  MOVWF  56
04DB:  MOVLW  E8
04DC:  MOVWF  55
04DD:  CALL   0F4
04DE:  MOVF   79,W
04DF:  MOVWF  31
04E0:  MOVF   78,W
04E1:  MOVWF  30
....................       //c=_mul(c1,100); //Otra alternativa para multiplicar int8*int8=int16 
....................       c=(int16)c1*100; //Convierto centemas, haciendo un CAST para obtener un int16 
04E2:  CLRF   3D
04E3:  MOVF   39,W
04E4:  MOVWF  3C
04E5:  MOVF   3D,W
04E6:  MOVWF  54
04E7:  MOVF   39,W
04E8:  MOVWF  53
04E9:  CLRF   56
04EA:  MOVLW  64
04EB:  MOVWF  55
04EC:  CALL   0F4
04ED:  MOVF   79,W
04EE:  MOVWF  33
04EF:  MOVF   78,W
04F0:  MOVWF  32
....................       d=d1*10; //Convierto decenas a numero  
04F1:  MOVF   3A,W
04F2:  MOVWF  51
04F3:  MOVLW  0A
04F4:  MOVWF  52
04F5:  CALL   109
04F6:  CLRF   35
04F7:  MOVF   78,W
04F8:  MOVWF  34
....................       u=u1; //Convierto unidades a numero  
04F9:  CLRF   37
04FA:  MOVF   3B,W
04FB:  MOVWF  36
....................        
....................       contra=m+c+d+u; 
04FC:  MOVF   32,W
04FD:  ADDWF  30,W
04FE:  MOVWF  3C
04FF:  MOVF   31,W
0500:  MOVWF  3D
0501:  MOVF   33,W
0502:  BTFSC  03.0
0503:  INCFSZ 33,W
0504:  ADDWF  3D,F
0505:  MOVF   34,W
0506:  ADDWF  3C,F
0507:  MOVF   35,W
0508:  BTFSC  03.0
0509:  INCFSZ 35,W
050A:  ADDWF  3D,F
050B:  MOVF   36,W
050C:  ADDWF  3C,W
050D:  MOVWF  2A
050E:  MOVF   3D,W
050F:  MOVWF  2B
0510:  MOVF   37,W
0511:  BTFSC  03.0
0512:  INCFSZ 37,W
0513:  ADDWF  2B,F
....................    } 
....................        
....................    WHILE(TRUE) 
....................    { 
....................       LCD_PUTC("\f"); 
0514:  MOVLW  2F
0515:  BSF    03.6
0516:  MOVWF  0D
0517:  MOVLW  00
0518:  MOVWF  0F
0519:  BCF    03.6
051A:  CALL   16C
....................       LCD_GOTOXY(1,1); 
051B:  MOVLW  01
051C:  MOVWF  4B
051D:  MOVWF  4C
051E:  CALL   12E
....................       LCD_PUTC(" DIGITE CLAVE "); 
051F:  MOVLW  30
0520:  BSF    03.6
0521:  MOVWF  0D
0522:  MOVLW  00
0523:  MOVWF  0F
0524:  BCF    03.6
0525:  CALL   16C
....................       LCD_GOTOXY(1,2); 
0526:  MOVLW  01
0527:  MOVWF  4B
0528:  MOVLW  02
0529:  MOVWF  4C
052A:  CALL   12E
....................       DELAY_MS(1000); 
052B:  MOVLW  04
052C:  MOVWF  3C
052D:  MOVLW  FA
052E:  MOVWF  4B
052F:  CALL   04C
0530:  DECFSZ 3C,F
0531:  GOTO   52D
....................       pedir_clave(); //Llama la funcion de pedir la clave 
0532:  CALL   26F
....................       if(k=='*') 
0533:  MOVF   24,W
0534:  SUBLW  2A
0535:  BTFSS  03.2
0536:  GOTO   539
....................          cambio_clave(); 
0537:  CALL   31B
0538:  GOTO   57F
....................       else 
....................       { 
....................          WHILE((k!='#')) 
0539:  MOVF   24,W
053A:  SUBLW  23
053B:  BTFSC  03.2
053C:  GOTO   543
....................          { 
....................             TECLADO(); 
053D:  CALL   227
....................             if(k=='*') 
053E:  MOVF   24,W
053F:  SUBLW  2A
0540:  BTFSC  03.2
....................                cambio_clave(); 
0541:  CALL   31B
0542:  GOTO   539
....................          } 
....................          IF(validar_clave()) //Aquí se compara si 
0543:  CALL   2C8
0544:  MOVF   78,F
0545:  BTFSC  03.2
0546:  GOTO   563
....................          //los números digitados 
....................          //están correctos.*/ 
....................          { 
....................             LCD_PUTC("\f"); //Se borra LCD 
0547:  MOVLW  38
0548:  BSF    03.6
0549:  MOVWF  0D
054A:  MOVLW  00
054B:  MOVWF  0F
054C:  BCF    03.6
054D:  CALL   16C
....................             LCD_GOTOXY(1,1);//Se ubica en la posición 1,1 
054E:  MOVLW  01
054F:  MOVWF  4B
0550:  MOVWF  4C
0551:  CALL   12E
....................             LCD_PUTC(" CLAVE CORRECTA "); 
0552:  MOVLW  39
0553:  BSF    03.6
0554:  MOVWF  0D
0555:  MOVLW  00
0556:  MOVWF  0F
0557:  BCF    03.6
0558:  CALL   16C
....................             BIT_SET(LED1); 
0559:  BSF    07.4
....................             DELAY_MS(2000); 
055A:  MOVLW  08
055B:  MOVWF  3C
055C:  MOVLW  FA
055D:  MOVWF  4B
055E:  CALL   04C
055F:  DECFSZ 3C,F
0560:  GOTO   55C
....................             BIT_CLEAR(LED1); 
0561:  BCF    07.4
....................          } 
0562:  GOTO   57F
....................          ELSE 
....................          { 
....................             LCD_PUTC("\f"); 
0563:  MOVLW  42
0564:  BSF    03.6
0565:  MOVWF  0D
0566:  MOVLW  00
0567:  MOVWF  0F
0568:  BCF    03.6
0569:  CALL   16C
....................             LCD_GOTOXY(1,2); 
056A:  MOVLW  01
056B:  MOVWF  4B
056C:  MOVLW  02
056D:  MOVWF  4C
056E:  CALL   12E
....................             LCD_PUTC(" CLAVE INVALIDA "); 
056F:  MOVLW  43
0570:  BSF    03.6
0571:  MOVWF  0D
0572:  MOVLW  00
0573:  MOVWF  0F
0574:  BCF    03.6
0575:  CALL   16C
....................             BIT_SET(LED2); 
0576:  BSF    07.7
....................             DELAY_MS(4000); 
0577:  MOVLW  10
0578:  MOVWF  3C
0579:  MOVLW  FA
057A:  MOVWF  4B
057B:  CALL   04C
057C:  DECFSZ 3C,F
057D:  GOTO   579
....................             BIT_CLEAR(LED2); 
057E:  BCF    07.7
....................          } 
....................       } 
057F:  GOTO   514
....................    } 
.................... } 
0580:  SLEEP

Configuration Fuses:
   Word  1: 2CF1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
